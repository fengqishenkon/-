//结构体内存对齐
在结构体的基础了解完了之后，我们应该知道结构体中的不同类型的数据类型在内存中的存储位置。

//代码1、
//对应图1
#include<stdio.h>
int main()
{
	struct s1
	{
		char x;
		int  a;
		double c;
	};
	
	return 0;
}

图1中可以看到中间三个内存空置，因为最大对齐数8的整数倍，刚好存放需要16个字节的大小，所以结构体的总大小为16.

/*结构体的对齐规则
1. 第一个成员在与结构体变量偏移量为0的地址处。
2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。 对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。 VS中默认的值为8。
3. 结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。
4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整 体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。
*/


//代码2、
//对应图2、
#include<stdio.h>
int main()
{
	struct s1
	{
		char x;
		int  a;
		double c;
	};
   struct s2
  {
    char d;
    struct s1 s;
    double f;             
  };
	return 0;
}

//图2中可以看见 第一个为d，第二个结构体中的最大对齐数是 8 ，所以起始位置是17。41是f的起始位置。结构体的整 体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。
//因为最大对齐数为8所以结构体的总大小是56。

为什么存在内存对齐？
1. 平台原因(移植原因)：
不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特 定类型的数据，否则抛出硬件异常。

2. 性能原因：
    数据结构(尤其是栈)应该尽可能地在自然边界上对齐。 原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

总体来说：
  结构体的内存对齐是拿空间来换取时间的做法。

