#define _CRT_SECURE_NO_WARNINGS 

//隐式类型的转换中的整型提升
//整形提升是按照变量的数据类型的符号位来提升的
//通用cpu是难以直接实现两个8比特字节直接相加运算，所以表达式中各种长度可能小于int长度的整型值
//都必须先转换为int或者unsigned int，然后才能送入cpu去执行运算。


//先来介绍一下字符的类型：字符是属于整形家族的。字符在内存中存储的是字符的ASCII，因为ASCII码值是整形，所以字符类型归类到整形家族

#include<stdio.h>
int main()
{

	char a = 5;
	//5这个数字是正数在内存中是00000000 00000000 00000000 00000101这个形式体现的。 四个字节每个字节8 bite位，总共32 bite位
	//但因为 a 是字符类型的变量所以只能存储一个字节（8 bite位）。所以是00000101这个形式
	char b = 126;
	//126是正数，在内存中是 00000000 00000000 00000000 01111110 
	//但因为 a 是字符类型的变量所以只能存储一个字节（8 bite位）。所以是01111110这个形式.
	char c = a + b;
	//a+b在计算时因为a和b都是字符类型的变量，长度小于int长度所以在计算时要整型提升
	//00000101-a
	//01111110-b
	//因为在vs上char==signed char.
	//所以a和b的符号位都是0
	// 整型提升完后
	//00000000 00000000 00000000 00000101-a
	//00000000 00000000 00000000 01111110-b
	//00000000 00000000 00000000 10000011 a+b
	//c是字符类型，所以只能存储一个字节的数字10000011
	print("%d\n", c);//在打印c时，用的是%d这表示打印出来的是整型，但c是字符型，所以又需要整型提升。
	//此时：因为c的符号位是1所以整型提升后是11111111 11111111 10000011
        //整型提升是在补码的基础上提升的，再用%d打印出来时，打印出来的是原码，所以 要补码转原码。
	// 11111111 11111111 10000011 这是补码
	// 10000000 00000000 01111100     反码
	// 10000000 00000000 01111101     原码
	//最后打印出来的数字 -125 
	return 0;
}
